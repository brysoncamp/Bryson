function B(n){return Array.from(new Set(n))}function $(n,e){const t=N();return t[n]=t[n]||e}function N(){const n="_vike";return globalThis[n]=globalThis[n]||{}}const l=new Proxy({},{get:(n,e)=>t=>e==="code"?`\`${t}\``:e==="string"?`'${t}'`:t}),E="0.4.229";let f;f??(f=W());function W(){return $("utils/assertSingleInstance.ts",{instances:[],alreadyLogged:new Set})}function b(){return f??(f=W()),f}const G="Client runtime of both Server Routing and Client Routing loaded https://vike.dev/client-runtimes-conflict",P="Client runtime loaded twice https://vike.dev/client-runtime-duplicated";function R(){const n=b();{const e=B(n.instances);h(e.length<=1,`vike@${l.bold(e[0])} and vike@${l.bold(e[1])} loaded which is highly discouraged, see ${l.underline("https://vike.dev/warning/version-mismatch")}`,{onlyOnce:!0,showStackTrace:!1})}n.checkSingleInstance&&n.instances.length>1&&h(!1,P,{onlyOnce:!0,showStackTrace:!0})}function X(n){const e=b();h(e.isClientRouting!==!1,G,{onlyOnce:!0,showStackTrace:!0}),h(e.isClientRouting===void 0,P,{onlyOnce:!0,showStackTrace:!0}),e.isClientRouting=!0,e.checkSingleInstance=!0,R()}function V(){b().instances.push(E),R()}function h(n,e,{onlyOnce:t,showStackTrace:r}){const o=b();if(n)return;const i=`[Vike][Warning] ${e}`;{const{alreadyLogged:a}=o,u=i;if(a.has(u))return;a.add(u)}console.warn(r?new Error(i):i)}function A(){return!(typeof process>"u"||!process.cwd||!process.versions||typeof process.versions.node>"u"||!process.release||process.release.name!=="node")}function k(n,e){const t=new Error(n);return A()&&(t.stack=H(t.stack,e)),t}function H(n,e){if(!n)return n;const t=z(n);let r=0;return t.filter(i=>i.includes(" (internal/")||i.includes(" (node:internal")?!1:r<e&&J(i)?(r++,!1):!0).join(`
`)}function J(n){return n.startsWith("    at ")}function z(n){return n.split(/\r?\n/)}function D(n){return typeof n=="object"&&n!==null}const s=$("utils/assert.ts",{alreadyLogged:new Set,logger(n,e){e==="info"?console.log(n):console.warn(n)},showStackTraceList:new WeakSet});V();const F="[vike]",U=`[vike@${E}]`,q="Bug",p=2;function Z(n,e){if(n)return;const t=(()=>{if(!e)return null;const a=typeof e=="string"?e:JSON.stringify(e);return l.dim(`Debug info (for Vike maintainers; you can ignore this): ${a}`)})();let o=[`You stumbled upon a Vike bug. Go to ${l.underline("https://github.com/vikejs/vike/issues/new?template=bug.yml")} and copy-paste this error. A maintainer will fix the bug (usually within 24 hours).`,t].filter(Boolean).join(" ");o=d(o),o=y(o,q),o=g(o,!0);const i=k(o,p);throw s.onBeforeLog?.(),i}function M(n,e,{showStackTrace:t,exitOnError:r}={}){if(n)return;t=t||s.alwaysShowStackTrace,e=d(e),e=y(e,"Wrong Usage"),e=g(e);const o=k(e,p);if(t&&s.showStackTraceList.add(o),s.onBeforeLog?.(),r)console.error(t?o:e),process.exit(1);else throw o}function K(n){return n=d(n),n=y(n,"Error"),n=g(n),k(n,p)}function Y(n,e,{onlyOnce:t,showStackTrace:r}){if(!n){if(r=r||s.alwaysShowStackTrace,e=d(e),e=y(e,"Warning"),e=g(e),t){const{alreadyLogged:o}=s,i=t===!0?e:t;if(o.has(i))return;o.add(i)}if(s.onBeforeLog?.(),r){const o=k(e,p);s.showStackTraceList.add(o),s.logger(o,"warn")}else s.logger(e,"warn")}}function ee(n,e,{onlyOnce:t}){e=d(e),e=g(e);{const{alreadyLogged:r}=s,o=e;if(r.has(o))return;r.add(o)}s.onBeforeLog?.(),s.logger(e,"info")}function y(n,e){let t=`[${e}]`;const r=e==="Warning"?"yellow":"red";return t=l.bold(l[r](t)),`${t}${n}`}function d(n){return n.startsWith("[")?n:` ${n}`}function g(n,e=!1){return`${e?U:F}${n}`}function S(n){const e=n/1e3;if(e<120){const t=L(e);return`${t} second${x(t)}`}{const t=e/60,r=L(t);return`${r} minute${x(r)}`}}function L(n){let e=n.toFixed(1);return e.endsWith(".0")&&(e=e.slice(0,-2)),e}function x(n){return n==="1"?"":"s"}const T=$("utils/executeHook.ts",{userHookErrors:new WeakMap,pageContext:null});function ne(n,e,t){const{hookName:r,hookFilePath:o,hookTimeout:{error:i,warning:a}}=e;let u,w;const _=new Promise((c,I)=>{u=j=>{m(),c(j)},w=j=>{m(),I(j)}}),m=()=>{v&&clearTimeout(v),O&&clearTimeout(O)},v=C(a)&&setTimeout(()=>{Y(!1,`The ${r}() hook defined by ${o} is slow: it's taking more than ${S(a)} (https://vike.dev/hooksTimeout)`,{onlyOnce:!1})},a),O=C(i)&&setTimeout(()=>{const c=K(`The ${r}() hook defined by ${o} timed out: it didn't finish after ${S(i)} (https://vike.dev/hooksTimeout)`);w(c)},i);return(async()=>{try{Q(t);const c=await n();u(c)}catch(c){D(c)&&T.userHookErrors.set(c,{hookName:r,hookFilePath:o}),w(c)}})(),_}function C(n){return!!n&&n!==1/0}function Q(n){T.pageContext=n,Promise.resolve().then(()=>{T.pageContext=null})}export{M as a,l as b,Y as c,Z as d,ne as e,K as f,$ as g,ee as h,D as i,X as j,Q as p,B as u};
